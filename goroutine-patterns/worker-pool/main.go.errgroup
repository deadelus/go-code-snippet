package workerpool

import (
	"context"
	"fmt"
	"time"

	"golang.org/x/sync/errgroup"
)

// Job represents a unit of work with input and output types
type Job[In, Out any] struct {
	Input  In
	Result chan Out
	Error  chan error
	Ctx    context.Context
}

// WorkerPool manages a pool of workers processing jobs concurrently
type WorkerPool[In, Out any] struct {
	workers   int
	jobs      chan Job[In, Out]
	done      chan struct{}
	processor func(context.Context, In) (Out, error)
}

// NewWorkerPool creates a new WorkerPool with the specified number of workers and processing function
func NewWorkerPool[In, Out any](workers int, processor func(context.Context, In) (Out, error)) *WorkerPool[In, Out] {
	return &WorkerPool[In, Out]{
		workers:   workers,
		jobs:      make(chan Job[In, Out]),
		done:      make(chan struct{}),
		processor: processor,
	}
}

// Start initializes the worker pool and begins processing jobs
func (p *WorkerPool[In, Out]) Start(ctx context.Context) {
	for i := 0; i < p.workers; i++ {
		// Launch each worker as a separate goroutine
		go func(workerID int) {
			for {
				select {
				case <-ctx.Done():
					return
				case job, ok := <-p.jobs:
					if !ok {
						return
					}
					fmt.Printf("Worker %d processing input: %v\n", workerID, job.Input)

					// Pass the context from the job to the processor
					results, err := p.processor(job.Ctx, job.Input)
					// If the context is cancelled, do not send results
					select {
					case <-job.Ctx.Done():
						// Optionally, you could send ctx.Err() on job.Error
					default:
						job.Result <- results
						job.Error <- err
					}
					close(job.Result)
					close(job.Error)
				}
			}
		}(i)
	}
}

// Submit adds a job to the worker pool and returns the result
func (p *WorkerPool[In, Out]) Submit(ctx context.Context, input In) (Out, error) {
	resultChan := make(chan Out)
	errorChan := make(chan error)
	select {
	case p.jobs <- Job[In, Out]{Input: input, Result: resultChan, Error: errorChan, Ctx: ctx}:
		select {
		case result := <-resultChan:
			err := <-errorChan
			return result, err
		case <-ctx.Done():
			return *new(Out), ctx.Err()
		}
	case <-ctx.Done():
		return *new(Out), ctx.Err()
	}
}

func main() {
	pool := NewWorkerPool(5, func(ctx context.Context, x int) (int, error) {
		time.Sleep(100 * time.Millisecond)
		if x == 5 {
			return 0, fmt.Errorf("error processing item %d", x)
		}
		return x * 2, nil
	})

	g, ctx := errgroup.WithContext(context.Background())
	pool.Start(ctx)
	results := make([]int, 10)
	for i := 0; i < 10; i++ {
		i := i
		g.Go(func() error {
			result, err := pool.Submit(ctx, i)
			if err != nil {
				return fmt.Errorf("error processing %d: %w", i, err)
			}
			results[i] = result
			return nil
		})
	}
	if err := g.Wait(); err != nil {
		fmt.Println("At least one error occurred:", err)
	}
	fmt.Println("Results:", results)
	for i, res := range results {
		fmt.Printf("Input: %d, Output: %d\n", i, res)
	}
}
